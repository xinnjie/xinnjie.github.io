# 文件系统为什么是这样的，如何实现？
相较于内存操作，磁盘的读写对于大多数人可能会陌生得多，因为生活中大多数时候我们会使用系统提供的文件操作或者使用更加“高级”的接口——数据库，完成对磁盘的读写。其中文件操作是由操作系统提供，然而在这套文件系统中，unix like 的系统本着“一切皆为文件”的设计原则整合出了一套优秀的文件抽象，将磁盘文件、网络套接字甚至一些系统信息（例如/etc/proc）都抽象为了文件，为涉及文件的操作提供了巨大的便利，大大降低了类文件操作的学习成本（比如在你使用过普通的文件读写函数后，套接字的读写操作一定难不倒你了）。


那么大家会不会对文件系统充满好奇，是什么样的设计以及底层实现让 api 如此易用，并且让其如此健壮（想想平时系统崩溃，数据大多数情况是不是都没事，丢失的基本都是还没来得及存入磁盘的数据）


下面第一节我们来更加概括性的讨论一下文件系统大致解决哪些问题，讨论完这些问题后，我们会继续讨论 unix-like 的文件系统是用了什么样的设计解决了这些问题。

## 文件系统需要解决哪些问题
* 文件的搜索 我们需要用一个路径名来找到我们想要的数据
* 文件的“聚集”  我们有时需要对一批文件进行操作，并且当一批文件有着某种联系时，我们希望它们可以作为一个整体存在。对应于“文件夹” 的概念
* 区别磁盘哪些部分是空闲的，哪些部分是被占用的，已经和磁盘的交互。
* 磁盘块的缓存。由于磁盘读写比内存读写慢几个数量级，想想如果我们如果我们打开编辑器进行写作，如果每次写入一个文字，都要对磁盘进行写入，那么我们也许有机会听到硬盘一直发出嗡嗡的噪音，响应也许也会变慢。因此我们必须对磁盘块进行缓冲，尽量减少磁盘的读写频率。


另外还有一些问题存在，但为了更简单的实现，我在源码分析中没有涉及，并且可能在这个简单的文件系统中并没有被实现。包括了以下内容
* 文件需要不易失、稳定，比如说不能应该一次意外的断电（比如停电了），就导致原有的文件都不可用了。  这部分功能对应了日志系统，不过这套日志系统一般不会向数据库的日志系统那么复杂。我在源码中没有实现日志模块，但会小小讨论一种简单日志的实现。
* 不同进程有同时操作文件系统的需求，要求文件系统能在并发操作中不被破坏，正常工作。这部分主要是通过加锁实现的。
## 文件系统的分层
![](%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E5%B1%82.png)

我所实现的文件系统一共分四层，作为对比，xv6分了六层：
![](%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/screenshot.png)


其中日志层我为了快点实现以及 xv6使用的日志系统实在太简陋太蠢了的原因去掉了（我就是懒，别戳破我~），路径查询层感觉完全可以放在目录层离。所以这两层没出现在我的文件系统分层里。

下面大致讲一下每层解决的问题以及基本的实现方式
## 每个层次解决的问题及基本的实现方式

###  磁盘缓冲层
磁盘缓冲层主要负责底层磁盘的交互与磁盘的交互和磁盘块的缓冲。磁盘缓冲层一方面简化了对磁盘的读写操作（你不可能每次都去调用磁盘接口那些繁琐的接口函数），另一方便缓存的存在大大减少了磁盘的读写次数。

* 磁盘交互:
假如要真的要对磁盘进行直接交互，你需要了解IDE、SATA等驱动接口的使用（基于汇编或 C的），每种接口都有不同的使用方式，不同的控制字设置对应于不同的功能。
比如说[AHCI - OSDev Wiki](https://wiki.osdev.org/AHCI)AHCI 是处理SATA硬盘的接口。总的来说不是很难，但是会很繁琐。
我为了能直接编译运行的目的（想想越过操作系统去对磁盘直接做操作也太疯狂太麻烦了，所以:) 才不是偷懒），用文件读写的方式模拟对硬盘的操作，思路是：一次性申请一个大的文件作为文件系统，人为将这个文件分成512字节长的块。比如说第712字节就在第1块的第200字节偏移的位置上，假如我要第2块磁盘块，我就从申请的文件读入1024~1076这些字节。

* 磁盘缓冲
在内存中维护一个Buf链表，每个 Buf 可以存对应于磁盘上的512字节内容，使用 LRU 算法，将最近使用的磁盘缓冲块放在链表头，不常使用的磁盘缓冲块放在磁盘尾，达到最近使用的磁盘块一直驻留在内存，不常用的磁盘块被替换出内存的目的。



### i 节点层
i 节点中文名叫匿名文件，除了没有名字外功能上已经和我们平时使用的文件概念很类似了(最主要的区别是一个 i 节点除了表示一个磁盘文件之外，也可以对应目录等类型）。

主要特点是你可以利用文件偏移随时读写 i 节点中任意一个字节。

* i 节点和磁盘块的关系
由于一个匿名文件大小往往会超过一个块的大小，所以一个i 节点往往会对应于多个磁盘块。所以 i 节点会存储一个数组用来存储所包含磁盘块的序号。

* 文件大小
每个 i 节点包含一个数字类型的 size 字段，用来记录 i 节点对应文件的大小（以字节计）

* 什么时候删除 i 节点
一般会记录一个`nlink`计数，每次有文件目录、硬链接指向该i节点时，计数就会增加。相反计数到达0时对应的文件就会被删除。   Linux 上的硬链接就是基于`nlink`实现的，`link`命令会调用文件系统的系统调用更改对应 i 节点的`nlink`计数

* 与磁盘缓冲层的互动
为了利用磁盘缓冲，i 节点用`ref(int)`字段记录当前被多少进程打开，当计数为0时，就可以释放掉该 i 节点所对应的所有磁盘缓冲块。

**有些小伙伴可能会注意到`nlink`和`ref`都是计数，有些许相似，但是实际上它们的用途完全不同。`nlink` 用来决定文件在磁盘上是否被删除，`ref`则与磁盘的缓冲有关**



附磁盘 i 节点的定义

磁盘 i 节点
```c++
/*
 * 每个磁盘 i 节点占64字节，每个磁盘块刚好可以装8个磁盘 i 节点
 */
struct Dinode {
    short type; // 区分文件、文件目录
    short nlink;  //  有多少个文件目录指向这个 i 节点
    unsigned int size;
    unsigned int addrs[NDIRECT+1];
    short uid; // 所有者
    short prl; // 权限
};
```


### 目录层
* 目录功能
目录对应的也是 i 节点——特殊类型的 i 节点。正常情况下，一个文件对应的 i 节点记录的磁盘块中会存储任意数据；而当一个 i 节点的类型为目录时，存储的数据就非常结构化，这种结构是由我们实现者规定的。比如我定义目录对应的数据块存储格式为 `DirEntry` 的数组，DirEntry的定义是这样的：
```c++
// 每个 DirEntry 占16字节
struct DirEntry {
    unsigned int inum;  // 这个目录项指向哪个文件 i 节点
    char name[12];
};
```
数组中的每个元素都包含一个名字和对应的 i 节点序号，通过这个序号又能找到对应的 i 节点内容。

可以看到文件名字的概念是在目录层产生，标志一个 i 节点的标识并不是名字，而是`inum `这样的序号。而在目录层，我们可以给不同的 i 节点取名字，，也可以给同一个 i 节点取不同的名字（对应了硬链接的概念）
* 文件的搜索
有了目录概念后，文件的搜索应该很多人都能想象了吧。
考虑一个`/Users/root/hello.txt`的路径，就是沿着根目录i节点对应磁盘数据中遍历`DirEntry`数组，直到找到一个`name`字段为”Users”的`DirEntry`，从i节点序号`inum`获取到“/Users”的i节点，重复上述过程，直到找到”hellot.txt”


### 文件描述符层
每次调用`fopen`打开文件，操作系统就会把对应于打开文件的`file`结构体放入到对应进程的文件表中。`file`中记录了诸如文件类型（磁盘文件、pipe、设备），`ref`计数（与i节点的`ref`语义并不同，这里是记录在当前进程被打开的次数），读写控制，当前文件读写偏移
* 文件读写控制
`readable`、`writeable`指明文件的可读可写性，由打开文件时的参数决定

* 整合管道、终端这类设备以及磁盘文件的读写。
由于所有读写都对文件描述符进行操作(文件描述符的数字是文件表中对应`file`结构体的序号)。这就做到了不直接对代表文件的`file`进行操作，增加了封装性。实际 `file`中通常会有一个字段`type`来标识文件的类型，read(),write() 这样的读写函数会通过识别文件的类型，调用不同的实现进行读写。
比如在支持pipe和磁盘文件两种类型文件中文件系统中，`file`结构体可能长这个样子
```c++
struct file {
  enum { FD_NONE, FD_PIPE, FD_INODE } type;
  int ref; // reference count
  char readable;
  char writable;
  struct pipe *pipe;
  struct inode *ip;
  uint off;
};
```
读写函数会根据`type`的不同，对`pipe`和`ip`进行不同方式的读写。这中运行时的多态性设计得非常朴实。


## 磁盘的组织
为了准确找到不同功能块在哪里，我们需要在创建文件系统时就组织好磁盘上所有块的分区，将不同区域划分到不同功能上。这样，当我们寻找数据块时，就不会错误读取磁盘元信息（i节点内容、超级块）等。注意不同的实现方式会对应于不同磁盘组织。

xc6的磁盘组织是这样的，启动块被放在第0块，保存 BootLoader 程序；第1块是超级块，超级块里存储了后面各个种类块的数量和起始下标等信息；第3部分是日志块，日志块的数量可以自定义；第4部分是i节点块，数量自定义；第5部分是位图块，用来记录哪些块是空闲的，那些块是被占用的。
```
[ boot block | super block | log blocks | inode blocks | free bit map | data blocks]
```


我自己实现的组织形式，由于去掉了日志功能，日志块就被省去了
```
[ boot block | super block | inode blocks | free bit map | data blocks]
```


请千万注意磁盘的组织非常依赖于实际的实现选择。比如稍微高级一些的记录哪些块是空闲方法还有**成组链接法**等，这种方法用链表实现了一个空闲块组成的栈，不需要位图，同时超级块（是一个栈的结构）的内容也和这里讲得不同。

## 一个完整的例子
一般通过例子来学习都能非常具体得体会了某项技术的实现方法，下面我举一个完整的创建一个文件后再进行打开然后进行读写的例子。

首先我们在根目录下创建 helloDir 目录，并进入helloDir，创建hello.txt 文件，并写入“hello, world”到hello.txt
注意这个例子基于我自己实现的文件系统，但是和xv6非常类似（少了日志功能）

创建文件
`mkdir /helloDir`

1. 系统调用层: 用模式为 create 的 `open()` 打开名为”/hello”的目录
	1. 模式为 create 的 `open()` 调用ialloc在磁盘i节点区域上找到一个空闲的i节点，设置i节点的字段，设置类型为目录类型(假设i节点序号为18，根目录的i节点序号为1)
	2. **文件表**中找到空闲的一个`file`，将其`type`字段置为`FD_DIR`(`FD_FIR`只是一个用来标记的数字)，在当前**进程打开文件表**中找到一个空闲的项，填入`file`的指针，得到该文件在**进程打开文件表**中的序号，作为即将创建文件的文件描述符
	3. 在根目录的i节点中写入hello的目录项，内容为 <“helloDir”, 18>
	4. 在hello i节点中写入<“..”, 1>  和 <“.”, 18>
	5. 将hello i节点和根目录i节点数据同步到磁盘上(到这一步文件夹已经被创建了) 回到系统调用层，open返回”/hello”对应`file`结构体在文件表的序号
2. 调用`close()`关闭文件描述
	1. 在当前进程打开文件表中找到以文件描述符作为下标的`file`指针将其置为null
	2. `file`的`ref`字段减一，表示一个进程关闭了这个文件，如果此时`ref`已经为0，那么将其`type`置为`FD_NONE`表示空闲，在内存中释放对应的内存i节点

有小伙伴可能注意到这里出现了两张文件表，再次进行说明
* 全局文件表
* 进程打开文件表
区别在于：**全局文件表**是真正存着`file`结构体的一条静态数组，**进程打开文件表**是每个进程独占的`file*`结构体指针的静态数组，每次关闭文件只是将`file`的`ref`字段减去1，并将**进程打开文件表**中对应的`file*`元素置为null，但是对应的`file`只有当`ref`到达0时，才会释放对应文件的资源（i节点），并将`type`字段置为`FD_NONE`表示空闲，下次打开文件时可以使用该空闲的`file`。


`cd helloDir`
1. 系统调用层: `chdir`到 helloDir
	1. 取得根目录`/`对应的i节点存储的目录数据，并且`/`根目录对应的i节点序号被固定为1(这是创建文件系统时人为设计的)
	2. 在根目录`/`i节点存储的目录数据中遍历直到找到叫”helloDir”的一个目录项，取出对应的`inum`节点序号
	3. 根据序号从磁盘中读出i节点
	4. 将当前进程的工作目录（cwd, current working directory）改为该节点 

`touch hello.txt`
1. 系统调用层:  用模式为create的`open()`创建 “hello.txt”，返回文件描述符`fd`
2. 系统调用层：用`close()`关闭该文件描述符`fd`对应的文件

`cat "hello, world" > hello.txt`
1. 系统调用层：用模式为WRITE_ONLY的`open()`打开文件 “hello.txt”，返回文件描述符`fd`
2. 系统调用层：`write()`将”hello, world”写入到对应于文件描述符`fd`的`file`中 
	1. 通过`/helloDir`的i节点获取目录信息，找到`name`字段为”hello.txt”的目录条目，假设对应的i节点序号`inum`为20
	2. 从磁盘i节点区读取第20个i节点，由于此时i节点刚被创建，储存数据长0字节，所以被该i节点分配磁盘块，磁盘块号写入 i节点的`addr`字段第0个元素
	3. 向新分配的磁盘块写入”hello,world”, 更新i节点字节长度`size`为11(“hello,world”长度为11)
	4. 由于i节点被修改，重新写入到磁盘
3. 系统调用层： `close()`关闭对应于文件描述符`fd`的`file`



## 总结
一个简易的文件系统是不是很简单，实现起来算上外围非核心的shell代码才1500行左右
这里就是我写的一个[简易文件系统](https://github.com/xinnjie/simple_file_system)，由于可以直接运行，所以推荐初学者用来学习。


参考文献
xv6-book
xv6 源码